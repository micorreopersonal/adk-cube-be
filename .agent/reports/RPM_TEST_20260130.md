# Reporte de Evaluación de RPM y Cuotas de API

**Fecha:** 2026-01-30
**Entorno:** Desarrollo Local (Vertex AI backend)
**Escenario:** Stress Test de Reportes Ejecutivos y Comparativas Directas

## 1. Resumen Ejecutivo
Se realizó una prueba de carga para medir la densidad de peticiones (RPM - Requests Per Minute) que genera el Agente de HR al resolver consultas complejas. El objetivo principal es determinar la viabilidad del Tier actual de Vertex AI ante el uso concurrente.

## 2. Métricas del Test
| KPI | Valor |
| :--- | :--- |
| **Consultas Totales** | 5 |
| **Consultas Exitosas** | 3 |
| **Llamadas a la API (Est.)** | 8 |
| **Tiempo Total** | 93.35s |
| **RPM Promedio** | **5.14** |
| **Pico de Turns por Consulta** | 3 (1 inicial + 2 llamadas a tools) |

## 3. Escenarios Probados
1. **Reporte Ejecutivo (Marzo 2024)**: ✅ Éxito (Turns: 2)
2. **Comparativa FFVV vs ADMI (Anual 2024)**: ✅ Éxito (Turns: 3)
3. **Tendencia Riesgos vs Operaciones (2024)**: ✅ Éxito (Turns: 3)
4. **Alertas de Talento (Julio 2024)**: ❌ Falla (Tool `get_talent_alerts` no encontrada en registro)
5. **Resumen Ejecutivo Anual (2024)**: ❌ Falla (Error de conversión `float NaN` en lógica de datos)

## 4. Hallazgos sobre Cuotas (RPM)
- **Densidad Multi-Turno**: Cada interacción del usuario genera un promedio de **2.6 llamadas a Gemini**. 
- **Límite de Tier**: Con un límite estándar de 15 RPM, apenas **5-6 usuarios concurrentes** realizando consultas complejas agotarían la cuota instantáneamente.
- **Latencia**: Las peticiones que requieren múltiples herramientas tienen una latencia promedio de **30s**, lo cual es aceptable para reportes pero crítico para la percepción de agilidad.

## 5. Recomendaciones de Optimización
1. **Consolidación de Herramientas**: Refactorizar las tools para que retornen datos complementarios (ej. `get_monthly_attrition` debería incluir benchmarks) para reducir los turns de "ida y vuelta".
2. **Implementación de Caché**: Implementar Redis o Firestore Cache para resultados de BigQuery con TTL de 24h.
3. **Manejo de Errores (429)**: El `router_logic.py` ya incluye una estrategia de reintento exponencial, pero se recomienda añadir un "Soft-Reject" en el frontend si la cuota está próxima al límite.

---
*Generado por Antigravity (ADK Governance)*
